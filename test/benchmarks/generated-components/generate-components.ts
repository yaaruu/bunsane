#!/usr/bin/env node

/**
 * Component Generator for Partition Benchmark Testing
 * 
 * Generates Comp1 to Comp100 (or any specified range) for testing
 * with many component partitions.
 * 
 * Usage:
 *   bun run test/benchmarks/generated-components/generate-components.ts
 *   bun run test/benchmarks/generated-components/generate-components.ts --count 50
 *   bun run test/benchmarks/generated-components/generate-components.ts --count 200 --prefix TestComp
 */

import * as fs from 'fs';
import * as path from 'path';

interface GeneratorOptions {
    count: number;
    prefix: string;
    outputDir: string;
}

function parseArgs(): GeneratorOptions {
    const args = process.argv.slice(2);
    const options: GeneratorOptions = {
        count: 100,
        prefix: 'Comp',
        outputDir: path.dirname(new URL(import.meta.url).pathname.replace(/^\/([A-Z]:)/, '$1'))
    };

    for (let i = 0; i < args.length; i++) {
        if (args[i] === '--count' && args[i + 1]) {
            options.count = parseInt(args[i + 1], 10);
            i++;
        } else if (args[i] === '--prefix' && args[i + 1]) {
            options.prefix = args[i + 1];
            i++;
        } else if (args[i] === '--output' && args[i + 1]) {
            options.outputDir = args[i + 1];
            i++;
        }
    }

    return options;
}

// Field type definitions for variety in generated components
const fieldTypes = [
    { name: 'string', type: 'string', generator: '`value_${Math.random().toString(36).slice(2, 10)}`' },
    { name: 'number', type: 'number', generator: 'Math.floor(Math.random() * 10000)' },
    { name: 'boolean', type: 'boolean', generator: 'Math.random() > 0.5' },
];

// Field name patterns for realistic component data
const fieldNamePatterns = [
    ['user_id', 'string'],
    ['entity_id', 'string'],
    ['name', 'string'],
    ['value', 'number'],
    ['count', 'number'],
    ['amount', 'number'],
    ['is_active', 'boolean'],
    ['enabled', 'boolean'],
    ['status', 'string'],
    ['category', 'string'],
    ['timestamp', 'string'],
    ['data', 'string'],
    ['score', 'number'],
    ['level', 'number'],
    ['priority', 'number'],
] as const;

function generateComponentCode(index: number, prefix: string): string {
    const className = `${prefix}${index}`;
    
    // Generate 3-5 fields per component for realistic testing
    const fieldCount = 3 + (index % 3); // 3, 4, or 5 fields
    const fields: string[] = [];
    const fieldDefs: string[] = [];
    
    for (let i = 0; i < fieldCount; i++) {
        const pattern = fieldNamePatterns[(index + i) % fieldNamePatterns.length];
        const fieldName = `${pattern[0]}_${i}`;
        const fieldType = pattern[1];
        
        fields.push(`    @CompData()\n    ${fieldName}!: ${fieldType};`);
        
        // Generate field value generator for the data generator map
        if (fieldType === 'string') {
            fieldDefs.push(`        ${fieldName}: \`${fieldName}_\${entityId.slice(-6)}_\${Math.random().toString(36).slice(2, 8)}\``);
        } else if (fieldType === 'number') {
            fieldDefs.push(`        ${fieldName}: Math.floor(Math.random() * 10000)`);
        } else if (fieldType === 'boolean') {
            fieldDefs.push(`        ${fieldName}: Math.random() > 0.5`);
        }
    }
    
    return `import { Component, CompData, ComponentRegistry, BaseComponent, type ComponentDataType } from "@/core/components";';

@Component
export class ${className} extends BaseComponent {
${fields.join('\n\n')}
}

// Data generator for this component
export function generate${className}Data(entityId: string): Record<string, any> {
    return {
${fieldDefs.join(',\n')}
    };
}
`;
}

function generateIndexFile(count: number, prefix: string): string {
    const imports: string[] = [];
    const exports: string[] = [];
    const componentNames: string[] = [];
    const dataGenerators: string[] = [];
    
    for (let i = 1; i <= count; i++) {
        const className = `${prefix}${i}`;
        imports.push(`import { ${className}, generate${className}Data } from './${className}';`);
        exports.push(`    ${className},`);
        exports.push(`    generate${className}Data,`);
        componentNames.push(`    '${className}',`);
        dataGenerators.push(`    ['${className}', generate${className}Data],`);
    }
    
    return `/**
 * Auto-generated index file for ${count} benchmark components
 * Generated by: generate-components.ts
 * 
 * Import this file to register all generated components:
 *   import { AllGeneratedComponents, componentDataGenerators } from './generated-components';
 */

${imports.join('\n')}

// Re-export all components
export {
${exports.join('\n')}
};

// Array of all component class names
export const AllGeneratedComponentNames = [
${componentNames.join('\n')}
] as const;

// Array of all component classes for iteration
export const AllGeneratedComponents = [
${componentNames.map(n => n.replace(/'/g, '').replace(',', '')).map(n => `    ${n.trim()},`).join('\n')}
];

// Map of component names to their data generators
export const componentDataGenerators = new Map<string, (entityId: string) => Record<string, any>>([
${dataGenerators.join('\n')}
]);

// Helper to get a random component class
export function getRandomComponent() {
    return AllGeneratedComponents[Math.floor(Math.random() * AllGeneratedComponents.length)];
}

// Helper to get a random component name
export function getRandomComponentName(): string {
    return AllGeneratedComponentNames[Math.floor(Math.random() * AllGeneratedComponentNames.length)];
}

// Helper to generate data for a component by name
export function generateDataForComponent(componentName: string, entityId: string): Record<string, any> | null {
    const generator = componentDataGenerators.get(componentName);
    return generator ? generator(entityId) : null;
}

console.log(\`Registered \${AllGeneratedComponents.length} generated components for benchmark testing\`);
`;
}

async function main() {
    const options = parseArgs();
    
    console.log(`üöÄ Generating ${options.count} components with prefix "${options.prefix}"...`);
    console.log(`üìÅ Output directory: ${options.outputDir}`);
    
    // Ensure output directory exists
    if (!fs.existsSync(options.outputDir)) {
        fs.mkdirSync(options.outputDir, { recursive: true });
    }
    
    // Generate individual component files
    for (let i = 1; i <= options.count; i++) {
        const className = `${options.prefix}${i}`;
        const fileName = `${className}.ts`;
        const filePath = path.join(options.outputDir, fileName);
        const code = generateComponentCode(i, options.prefix);
        
        fs.writeFileSync(filePath, code);
        
        if (i % 20 === 0) {
            console.log(`‚úÖ Generated ${i}/${options.count} components...`);
        }
    }
    
    // Generate index file
    const indexPath = path.join(options.outputDir, 'index.ts');
    const indexCode = generateIndexFile(options.count, options.prefix);
    fs.writeFileSync(indexPath, indexCode);
    
    console.log(`‚úÖ Generated index.ts with all exports`);
    console.log(`\nüéâ Successfully generated ${options.count} components!`);
    console.log(`\nüìù Usage:`);
    console.log(`   Import all components: import './test/benchmarks/generated-components';`);
    console.log(`   Or import specific: import { ${options.prefix}1, ${options.prefix}50 } from './test/benchmarks/generated-components';`);
    console.log(`   Use helpers: import { AllGeneratedComponents, componentDataGenerators } from './test/benchmarks/generated-components';`);
}

main().catch(console.error);

