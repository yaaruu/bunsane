import { describe, it, expect, beforeEach, mock } from "bun:test";
import { GraphQLSchemaOrchestrator } from "../../../gql/orchestration/GraphQLSchemaOrchestrator";
import { GraphQLSchema } from "graphql";
import { GraphQLOperation } from "../../../gql/Generator";

// Mock services for testing
class MockUserService {
    @GraphQLOperation({ type: "Query" })
    async getUser(id: string) {
        return { id, name: "John Doe" };
    }

    @GraphQLOperation({ type: "Mutation" })
    async createUser(input: { name: string }) {
        return { id: "123", name: input.name };
    }
}

class MockProductService {
    @GraphQLOperation({ type: "Query" })
    async getProduct(id: string) {
        return { id, name: "Test Product" };
    }
}

describe("GraphQLSchemaOrchestrator", () => {
    let orchestrator: GraphQLSchemaOrchestrator;

    beforeEach(() => {
        orchestrator = new GraphQLSchemaOrchestrator();
    });

    describe("generateSchema", () => {
        it("should generate a complete GraphQL schema from services", async () => {
            const services = [new MockUserService(), new MockProductService()];

            const schema = await orchestrator.generateSchema(services);

            expect(schema).toBeInstanceOf(GraphQLSchema);

            // Verify schema has expected types
            const typeMap = schema.getTypeMap();
            expect(typeMap.Query).toBeDefined();
            expect(typeMap.Mutation).toBeDefined();
            // Note: User and Product types would be generated by full type inference
            // which is not yet implemented in the graph-based approach
        });

        it("should handle empty services array", async () => {
            const schema = await orchestrator.generateSchema([]);

            expect(schema).toBeNull();
        });

        it("should sort operations alphabetically", async () => {
            // Create services with operations that should be sorted
            class TestService {
                @GraphQLOperation({ type: "Query" })
                async zebra() { return "zebra"; }

                @GraphQLOperation({ type: "Query" })
                async alpha() { return "alpha"; }

                @GraphQLOperation({ type: "Mutation" })
                async zebraMutation() { return "zebra"; }

                @GraphQLOperation({ type: "Mutation" })
                async alphaMutation() { return "alpha"; }
            }

            const services = [new TestService()];
            const schema = await orchestrator.generateSchema(services);

            // Verify operations are sorted alphabetically
            const queryType = schema.getQueryType();
            const mutationType = schema.getMutationType();

            if (queryType && mutationType) {
                const queryFields = Object.keys(queryType.getFields());
                const mutationFields = Object.keys(mutationType.getFields());

                expect(queryFields).toEqual(["alpha", "zebra"]);
                expect(mutationFields).toEqual(["alphaMutation", "zebraMutation"]);
            }
        });
    });

    describe("buildGraphFromServices", () => {
        it("should build graph with correct number of nodes", async () => {
            const services = [new MockUserService(), new MockProductService()];

            // Access private method for testing
            const orchestratorAny = orchestrator as any;
            await orchestratorAny.buildGraphFromServices(services);

            const graph = orchestrator.getSchemaGraph();
            expect(graph.size()).toBeGreaterThan(0);
        });
    });

    describe("runPreprocessingVisitors", () => {
        it("should run preprocessing visitors without errors", async () => {
            const services = [new MockUserService()];
            const orchestratorAny = orchestrator as any;

            await orchestratorAny.buildGraphFromServices(services);
            await orchestratorAny.runPreprocessingVisitors();

            // Should not throw and graph should still be valid
            const graph = orchestrator.getSchemaGraph();
            expect(graph.size()).toBeGreaterThan(0);
        });
    });

    describe("runGenerationVisitors", () => {
        it("should generate typeDefs and resolvers", async () => {
            const services = [new MockUserService()];
            const orchestratorAny = orchestrator as any;

            await orchestratorAny.buildGraphFromServices(services);

            const results = await orchestratorAny.runGenerationVisitors();

            expect(results.typeDefs).toBeDefined();
            expect(typeof results.typeDefs).toBe("string");
            expect(results.typeDefs.length).toBeGreaterThan(0);

            expect(results.resolvers).toBeDefined();
            expect(typeof results.resolvers).toBe("object");
        });
    });

    describe("sortOperationsAlphabetically", () => {
        it("should sort operations within each type", () => {
            const orchestratorAny = orchestrator as any;

            const generationResults = {
                typeDefs: "",
                resolvers: {
                    Query: {
                        zebra: () => "zebra",
                        alpha: () => "alpha",
                        beta: () => "beta"
                    },
                    Mutation: {
                        zebraMutation: () => "zebra",
                        alphaMutation: () => "alpha"
                    }
                }
            };

            orchestratorAny.sortOperationsAlphabetically(generationResults);

            expect(Object.keys(generationResults.resolvers.Query)).toEqual(["alpha", "beta", "zebra"]);
            expect(Object.keys(generationResults.resolvers.Mutation)).toEqual(["alphaMutation", "zebraMutation"]);
        });
    });

    describe("createGraphQLSchema", () => {
        it("should create valid GraphQL schema", () => {
            const orchestratorAny = orchestrator as any;

            const generationResults = {
                typeDefs: `
                    type Query {
                        test: String
                    }
                `,
                resolvers: {
                    Query: {
                        test: () => "Hello World"
                    }
                }
            };

            const schema = orchestratorAny.createGraphQLSchema(generationResults);

            expect(schema).toBeInstanceOf(GraphQLSchema);
            expect(schema.getQueryType()).toBeDefined();
        });

        it("should throw error for invalid typeDefs", () => {
            const orchestratorAny = orchestrator as any;

            const generationResults = {
                typeDefs: "invalid graphql syntax {{{",
                resolvers: {}
            };

            expect(() => orchestratorAny.createGraphQLSchema(generationResults)).toThrow();
        });
    });

    describe("getSchemaGraph", () => {
        it("should return the current schema graph", () => {
            const graph = orchestrator.getSchemaGraph();
            expect(graph).toBeDefined();
            expect(typeof graph.size).toBe("function");
        });
    });

    describe("clear", () => {
        it("should clear the orchestrator state", async () => {
            const services = [new MockUserService()];
            await orchestrator.generateSchema(services);

            // Graph should have nodes
            expect(orchestrator.getSchemaGraph().size()).toBeGreaterThan(0);

            orchestrator.clear();

            // Graph should be empty
            expect(orchestrator.getSchemaGraph().size()).toBe(0);
        });
    });

    describe("error handling", () => {
        it("should handle service scanning errors", async () => {
            // Create a service that might cause scanning issues
            const problematicService = {
                invalidDecorator: "not a function"
            };

            const schema = await orchestrator.generateSchema([problematicService]);
            expect(schema).toBeNull(); // Invalid services result in no schema
        });

        it("should handle visitor execution errors", async () => {
            // Mock a service that causes visitor errors
            const services = [new MockUserService()];

            // This should handle any errors gracefully
            // In a real scenario, we might mock specific visitor failures
            const schema = await orchestrator.generateSchema(services);
            expect(schema).toBeInstanceOf(GraphQLSchema);
        });
    });

    describe("integration workflow", () => {
        it("should complete full generation workflow", async () => {
            const services = [new MockUserService(), new MockProductService()];

            // This tests the complete integration
            const schema = await orchestrator.generateSchema(services);

            expect(schema).toBeInstanceOf(GraphQLSchema);

            // Verify we can execute a query
            const queryType = schema.getQueryType();
            expect(queryType).toBeDefined();

            if (queryType) {
                const fields = queryType.getFields();
                expect(Object.keys(fields).length).toBeGreaterThan(0);

                // Should have getUser and getProduct operations
                expect(fields.getUser).toBeDefined();
                expect(fields.getProduct).toBeDefined();
            }
        });
    });
});